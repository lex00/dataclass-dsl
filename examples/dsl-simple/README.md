# MyFancyDSL

A simple example DSL built with [dataclass-dsl](https://github.com/lex00/dataclass-dsl).

## Features Demonstrated

- **Custom decorator**: `@my_fancy_dsl`
- **Multi-file organization**: Each thing in its own file with `from . import *`
- **No-parens pattern**: References like `parent = MyFancyThing1` and `parent_id = MyFancyThing1.Id`
- **Automatic dependency detection**: Finds references in both class and attribute form
- **Topological ordering**: Things sorted so dependencies come first
- **Template aggregation**: Collect all things from registry
- **JSON serialization**: Convert to JSON with reference placeholders
- **IDE stub generation**: Auto-generated `.pyi` file for type checking

## Installation

```bash
cd examples/dsl-simple
uv sync
```

## Usage

### Import all things

```python
from my_fancy_dsl.things import *

# All things are available
print(MyFancyThing1)
print(MyFancyThing2)
print(MyFancyThing3)
```

### Create instances

```python
from my_fancy_dsl.things import *

thing1 = MyFancyThing1(name="my-thing", value=42, tags=["a", "b"])
thing2 = MyFancyThing2(name="child", enabled=False)
thing3 = MyFancyThing3(name="grandchild", count=10)
```

### Check dependencies

```python
from my_fancy_dsl import get_all_dependencies
from my_fancy_dsl.things import *

deps = get_all_dependencies(MyFancyThing3)
print(deps)  # {<class 'MyFancyThing2'>}

deps = get_all_dependencies(MyFancyThing2)
print(deps)  # {<class 'MyFancyThing1'>}
```

### Get creation order

```python
from my_fancy_dsl import get_creation_order
from my_fancy_dsl.things import *

order = get_creation_order([MyFancyThing3, MyFancyThing1, MyFancyThing2])
print([t.__name__ for t in order])
# ['MyFancyThing1', 'MyFancyThing2', 'MyFancyThing3']
```

### Serialize to JSON

```python
from my_fancy_dsl import MyFancyDSLTemplate
from my_fancy_dsl.things import *  # noqa: F401

template = MyFancyDSLTemplate.from_registry(
    description="Example data structure"
)

print(template.to_json())
```

Output:
```json
{
  "Description": "Example data structure",
  "Resources": {
    "MyFancyThing1": {
      "type": "MyFancyThing1",
      "properties": {
        "name": "thing1-default",
        "value": 100,
        "tags": []
      }
    },
    "MyFancyThing2": {
      "type": "MyFancyThing2",
      "properties": {
        "name": "thing2-default",
        "enabled": true
      }
    },
    "MyFancyThing3": {
      "type": "MyFancyThing3",
      "properties": {
        "name": "thing3-default",
        "config": {},
        "count": 0
      }
    }
  }
}
```

## Running Tests

```bash
uv run pytest
```

## Project Structure

```
dsl-simple/
├── pyproject.toml
├── README.md
├── src/
│   └── my_fancy_dsl/
│       ├── __init__.py      # Decorator, registry, provider, template
│       └── things/
│           ├── __init__.py  # setup_resources() with StubConfig
│           ├── __init__.pyi # Auto-generated IDE stub
│           ├── thing1.py    # MyFancyThing1 (no deps)
│           ├── thing2.py    # MyFancyThing2 (depends on Thing1)
│           └── thing3.py    # MyFancyThing3 (depends on Thing2)
└── tests/
    └── test_my_fancy_dsl.py
```

## IDE Stub Generation

The `__init__.pyi` stub file is auto-generated by `setup_resources()` when you provide a `StubConfig`. This gives IDEs full type information for the star import pattern.

In `things/__init__.py`:

```python
from dataclass_dsl import StubConfig, setup_resources
from my_fancy_dsl import my_fancy_dsl

stub_config = StubConfig(
    package_name="my_fancy_dsl",
    core_imports=["my_fancy_dsl"],
)

setup_resources(
    __file__,
    __name__,
    globals(),
    stub_config=stub_config,
    extra_namespace={"my_fancy_dsl": my_fancy_dsl},
)
```

The generated stub exports all thing classes with proper type hints, so `from . import *` works with full IDE support (autocomplete, go-to-definition, type checking).
