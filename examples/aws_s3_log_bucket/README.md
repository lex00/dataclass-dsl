# AWS S3 Log Bucket Example

This example shows real output from [wetwire-aws](https://github.com/lex00/wetwire/tree/main/python/packages/wetwire-aws), a domain package built on dataclass-dsl.

## Installation

```bash
cd examples/aws_s3_log_bucket
uv sync
```

This installs the example package with its dependency on `wetwire-aws`.

## File Structure

```
aws_s3_log_bucket/
├── __init__.py    # Package loader
├── __init__.pyi   # IDE stub (auto-generated)
├── storage.py     # Component resources (encryption, versioning, etc.)
└── bucket.py      # Main LogBucket resource (references storage.py classes)
```

The resources are split across two files to demonstrate cross-file references.

## How dataclass-dsl Powers Each File

### `__init__.py` — The Loader

```python
from wetwire_aws.loader import setup_resources

setup_resources(__file__, __name__, globals())
```

This single call uses dataclass-dsl's `setup_resources()` to:

1. **Discover** all `.py` files in the package
2. **Parse** them to find class definitions and their dependencies
3. **Build a dependency graph** from resource references
4. **Topologically sort** the files so dependencies load first
5. **Inject** already-loaded classes into each module's namespace
6. **Register** each class in the global registry

This is why `storage.py` can use `from . import *` and reference classes that might be defined in other files.

### `storage.py` — Component Resources

```python
# Note: Split from bucket.py to demonstrate cross-file references.
from . import *

class LogBucketEncryptionDefault(s3.Bucket.ServerSideEncryptionByDefault):
    sse_algorithm = s3.ServerSideEncryption.AES256

class LogBucketEncryption(s3.Bucket.BucketEncryption):
    server_side_encryption_configuration = [LogBucketEncryptionRule]
...
```

### `bucket.py` — Main Resource

```python
# Note: LogBucketEncryption etc. are defined in storage.py but available
# here via `from . import *` — no explicit imports needed.
from . import *

class LogBucket(s3.Bucket):
    bucket_encryption = LogBucketEncryption
    public_access_block_configuration = LogBucketPublicAccessBlock
    versioning_configuration = LogBucketVersioning
```

The decorator (applied automatically by the loader) uses dataclass-dsl to:

1. **Transform** each class into a dataclass
2. **Detect** references like `LogBucketEncryption` as dependencies
3. **Register** the class in the registry for later discovery
4. **Apply RefMeta** so attribute access like `LogBucket.Arn` returns an `AttrRef`

Users never see decorators — the loader applies them transparently.

**Cross-file references work** because `setup_resources()` loads `storage.py` before `bucket.py` (topological order), making `LogBucketEncryption` available when `bucket.py` executes.

### `__init__.pyi` — IDE Stub

```python
from wetwire_aws.resources import s3, ec2, lambda_, ...
from .storage import LogBucket, LogBucketEncryption, ...
```

Generated by dataclass-dsl's `StubConfig`, this file:

1. **Exports** all AWS resource modules for IDE autocomplete
2. **Re-exports** the classes defined in `storage.py`
3. **Enables** type checking for `from . import *`

Without this stub, IDEs can't provide autocomplete for dynamic imports.

## How the Registry and Sorting Work

When you import this package:

1. `setup_resources()` loads `storage.py`
2. Each class is decorated and **registered** in a global `ResourceRegistry`
3. The registry tracks class names, types, and which module they came from
4. When building output, `Template.from_registry()` collects all registered classes
5. **Topological sorting** orders them so `LogBucketEncryptionDefault` comes before `LogBucketEncryptionRule` which comes before `LogBucketEncryption`

This ensures serialization always produces valid output with dependencies declared before dependents.

## Generated CloudFormation Output

```python
from examples.aws_s3_log_bucket import *
from wetwire_aws import CloudFormationTemplate

template = CloudFormationTemplate.from_registry(
    scope_package='examples.aws_s3_log_bucket'
)
print(template.to_yaml())
```

Produces:

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  LogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
```

Clean DSL in, valid CloudFormation out.

## Building Your Own Domain Package

Anyone can build a domain package like wetwire-aws. See the [Internals Guide](../../docs/INTERNALS.md) for:

- Creating a decorator with `create_decorator()`
- Setting up a loader with `setup_resources()`
- Implementing a `Provider` for serialization
- Generating IDE stubs with `StubConfig`

## Source

This example is from: https://github.com/lex00/wetwire/tree/main/python/packages/wetwire-agent/tests/domains/aws/scenarios/s3_log_bucket/results/beginner/generated
